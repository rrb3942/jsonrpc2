package jsonrpc2

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
)

var (
	// ErrHTTPEmptyResponse indicates that the HTTP server returned a successful status code (2xx)
	// and an "application/json" Content-Type, but the response body was empty.
	ErrHTTPEmptyResponse = errors.New("jsonrpc2/httpbridge: empty JSON response body")
	// ErrHTTPResponse indicates a non-successful HTTP status code (not 2xx) was received.
	// The specific status is included in the error message generated by Decode.
	ErrHTTPResponse = errors.New("jsonrpc2/httpbridge: HTTP response error")
	// ErrHTTPNoJSON indicates that the HTTP server returned a successful status code (2xx)
	// but the Content-Type header was not "application/json".
	ErrHTTPNoJSON = errors.New("jsonrpc2/httpbridge: response Content-Type was not application/json")
)

// HTTPBridge provides a combined [Encoder] and [Decoder] implementation that
// communicates with a JSON-RPC server over HTTP(S). It uses a standard [net/http.Client]
// to send POST requests with JSON payloads and expects JSON responses.
//
// Each call to [HTTPBridge.Encode] sends an HTTP request and stores the response.
// The subsequent call to [HTTPBridge.Decode] processes that stored response.
//
// IMPORTANT: An HTTPBridge instance is NOT safe for concurrent use by multiple goroutines.
// It maintains internal state related to the last request/response cycle.
// However, it is safe to use within a [*Client] or [*ClientPool], as these types
// provide the necessary synchronization before calling Encode/Decode.
//
// Use [NewHTTPBridge] to create instances.
type HTTPBridge struct {
	client     *http.Client // The underlying HTTP client.
	url        string       // The target URL for JSON-RPC requests.
	respStatus string
	respBuffer bytes.Buffer
	respCode   int
	closed     bool
	respJSON   bool         // Flag indicating if the last response had Content-Type: application/json.
}

// NewHTTPBridge creates a new [*HTTPBridge] configured to send JSON-RPC requests
// via HTTP POST to the specified url. It initializes an internal [net/http.Client]
// with default settings.
//
// Example:
//
//	bridge := NewHTTPBridge("https://api.example.com/rpc")
//	// Typically, the bridge is then used with a Client:
//	rpcClient := NewClient(bridge, bridge) // Use bridge for both encoding and decoding
//	defer rpcClient.Close() // This will call bridge.Close()
//	// Use rpcClient for making calls...
func NewHTTPBridge(url string) *HTTPBridge {
	return &HTTPBridge{url: url, client: new(http.Client)}
}

// Close terminates the bridge, closing any idle connections held by the underlying
// [net/http.Client]. Subsequent calls to [HTTPBridge.Encode] or [HTTPBridge.Decode]
// will return [io.EOF]. This method is typically called via [Client.Close].
func (h *HTTPBridge) Close() error {
	h.client.CloseIdleConnections() // Release resources held by the http client.
	h.closed = true                // Mark the bridge as closed.

	return nil
}

// Encode marshals the provided value `v` to JSON and sends it as an HTTP POST
// request to the configured URL. It implements the [Encoder] interface.
//
// It sets the "Content-Type" header to "application/json". The HTTP response
// status, headers, and body are stored internally for processing by the next
// call to [HTTPBridge.Decode].
//
// If the bridge is closed, it returns [io.EOF]. Context cancellation is respected
// during the HTTP request. Errors during JSON marshaling or the HTTP request
// are returned directly. If the HTTP request completes successfully (regardless of
// status code), this method returns nil; response handling occurs in Decode.
func (h *HTTPBridge) Encode(ctx context.Context, v any) error {
	if h.closed {
		return io.EOF // Bridge is closed.
	}

	h.respBuffer.Reset()
	h.respStatus = ""
	h.respCode = 0
	h.respJSON = false

	buf, err := Marshal(v)

	if err != nil {
		// Propagate marshal errors instead of swallowing them
		return err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, h.url, bytes.NewReader(buf))

	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := h.client.Do(req)

	if err != nil {
		return err
	}

	defer resp.Body.Close()

	// Record response for decode
	h.respCode = resp.StatusCode
	h.respStatus = resp.Status

	if resp.Header.Get("Content-Type") == "application/json" {
		h.respJSON = true

		// ReadFrom can return io.EOF which is not an error in this context
		_, err := h.respBuffer.ReadFrom(resp.Body)
		if err != nil && !errors.Is(err, io.EOF) {
			return fmt.Errorf("http: failed to read response body: %w", err)
		}
	}

	// Technically we sent the request fine, so let decode figure it out
	// Technically we sent the request fine, so let decode figure it out
	return nil
}

// Decode processes the HTTP response received by the previous [HTTPBridge.Encode] call
// and attempts to unmarshal the JSON body into the value pointed to by `v`.
// It implements the [Decoder] interface.
//
// Behavior depends on the stored response:
//   - If the bridge is closed, returns [io.EOF].
//   - If the context is cancelled, returns the context error.
//   - If the response had a "Content-Type" of "application/json" and a non-empty body,
//     attempts to unmarshal the body into `v`. Returns any unmarshaling error.
//   - If the response was JSON but the body was empty, returns [ErrHTTPEmptyResponse].
//   - If the response had a successful status code (2xx) but was not JSON,
//     returns [ErrHTTPNoJSON].
//   - If the response had a non-successful status code (not 2xx), returns [ErrHTTPResponse].
//
// The specific HTTP status is included in the formatted error messages for
// [ErrHTTPEmptyResponse], [ErrHTTPNoJSON], and [ErrHTTPResponse].
func (h *HTTPBridge) Decode(ctx context.Context, v any) error {
	// Check context cancellation first.
	if err := ctx.Err(); err != nil {
		return err
	}

	if h.closed {
		return io.EOF // Bridge is closed.
	}

	// Check if the previous Encode call received a JSON response.
	if h.respJSON {
		// Check if the response body buffer actually contains data.
		if h.respBuffer.Len() > 0 {
			// Attempt to unmarshal the stored response body.
			return Unmarshal(h.respBuffer.Bytes(), v)
		}
		// JSON content type was set, but the body was empty.
		return fmt.Errorf("%w (status: %s)", ErrHTTPEmptyResponse, h.respStatus)
	}

	// Response was not marked as JSON. Check the status code.
	if h.respCode >= 200 && h.respCode < 300 {
		// Successful status code, but not JSON content type.
		return fmt.Errorf("%w (status: %s)", ErrHTTPNoJSON, h.respStatus)
	}

	// Non-successful status code (e.g., 4xx, 5xx).
	return fmt.Errorf("%w (status: %s)", ErrHTTPResponse, h.respStatus)
}

// Unmarshal implements the [Decoder] interface's Unmarshal method.
// It simply delegates to the package-level [Unmarshal] variable (which defaults
// to [encoding/json.Unmarshal]). This method is required by the [Decoder] interface
// but is not typically used directly with HTTPBridge, as decoding happens
// within the [HTTPBridge.Decode] method based on the HTTP response.
func (h *HTTPBridge) Unmarshal(data []byte, v any) error {
	// Delegates to the package-level Unmarshal variable.
	return Unmarshal(data, v)
}
